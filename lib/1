import config from './config';

//class that represents polynomials as bit arrays
export class Polynomial {
  /*represents a polynomial whose coefficients are binary
   * @constructor
   *@param {number} value - an integer, that when converted to binary, represents a polynomial
   */
  constructor(value) {
    this.value = value;
  }
  /*returns the integer value of the polynomial
   *For example: If the value is 3, then the binary value is 011
   *and the polynomial is x+1
   */
  getValue() {
    return this.value;
  }
  /*sets the value of the polynomial. For
   * example, setting the value to 3,
   * sets the polynomial to 011, which is
   * x + 1
   *@param {number} value : an integer, that when converted to binary represents a polynomial
   */
  setValue(value) {
    this.value = value;
  }
  /*adds one polynomial in GF(2^n) to another polynomial in GF(2^n)
   * rightHandPolynomial is the polynomial to add to this.value
   *@param {number} rightHandPolynomial - an integer whose binary form
   *represents a polynomial*/
  plus(rightHandPolynomial) {
    this.value = this.value ^ rightHandPolynomial;
    return this;
  }
  /*multiplies this.value by a monomial of degree n - for example x^3 or x^2 or x (where ^ represents "to the power of")
   * @param n {number}
   */
  timesMonomialOfDegree(n) {
    this.value = this.value << n;
    return this;
  }
  /*subtract terms above given degree by bit-wise &
     *@param {number} n -degree that we should subtract, if degree is 3, we delete all terms of 1000 and above
     */
  subtractTermsAboveDegree(n) {
    this.value = this.value & (Math.pow(2, n + 1) - 1);
    return this;
  }
  /*converts a polynomial represented by a bit array
   * to integer form
   */
  static toIntegerForm(bitArray) {
    return parseInt(bitArray, 2);
  }
  static toPolynomialForm(integer) {
    return new Number(integer).toString(2);
  }
}

export class CharacteristicTwoGaloisField {
  constructor(numElements) {
    this.n = Math.log2(numElements);
    if (
      this.n &&
      (this.n % 1 !== 0 || this.n < config.minBits || this.n > config.maxBits)
    ) {
      throw new Error(
        'Number of n must be an integer between ' +
          config.minBits +
          ' and ' +
          config.maxBits +
          ', inclusive.'
      );
    }
    this.numberOfElementsInField = numElements;
    this.computeLogAndExpTables();
  }
  fieldContains(value) {
    return value < this.numberOfElementsInField;
  }
  getExponentOfNextDegree(expOfCurrentDegree) {
    let primitivePolynomial = config.primitivepolynomials[this.n];
    var polynomial = expOfCurrentDegree.timesMonomialOfDegree(1);
    if (!this.fieldContains(polynomial.getValue())) {
      polynomial = polynomial
        .plus(primitivePolynomial)
        .subtractTermsAboveDegree(this.n - 1);
    }
    return polynomial;
  }
  computeLogAndExpTables() {
    this.exps = [];
    this.logs = [];
    let polynomial = new Polynomial(1);
    for (var i = 0; i < this.numberOfElementsInField; i++) {
      this.exps[i] = polynomial.getValue();
      this.logs[polynomial.getValue()] = i;
      polynomial = this.getExponentOfNextDegree(polynomial);
    }
  }
  multiply(polynomialOne, polynomialTwo) {
    return new Polynomial(
      this.exps[
        (this.logs[polynomialOne] + this.logs[polynomialTwo]) %
          (this.numberOfElementsInField - 1)
      ]
    );
  }
}
